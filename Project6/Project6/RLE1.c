//#include<stdio.h>
//#define N 256*256
//unsigned char results[N] = { '\0' };	//encoding한 데이터를 저장할 배열을 전역변수로 선언
//
//int encoding(unsigned char num[N]) {
//	int i, cnt = 1, idx = 0;
//
//	printf("인코딩 후 : ");
//	for (i = 0; i < N; i++)
//	{
//		if (num[i] == 0)	//배열의 데이터가 끝나면 반복문 탈출
//		{
//			printf("\n Finish\n");
//			break;
//		}
//		if ((num[i] != num[i + 1]) || (cnt == 255))	//다음 번지의 데이터와 다르거나 반복횟수가 255가 되면 빈 배열에 반복횟수와 데이터를 저장
//		{
//			results[idx] = cnt;
//			results[idx + 1] = num[i];	//데이터는 다음칸에 저장해야하므로 idx+1
//			cnt = 1;	//cnt를 다시 1로 초기화
//			printf("%d%c", results[idx], results[idx + 1]);
//			idx += 2;	//반복횟수와 데이터를 2칸씩 저장하기 때문에 2씩 증가
//		}
//		else
//		{
//			cnt++;
//		}
//	}return;
//}
//
//int decoding(unsigned char en_number[N]) {
//	int i, j, idx = 0;
//	unsigned char de_number[2 * N] = { 0, };
//	for (i = 0;; i += 2)
//	{
//		if (en_number[i] == 0)
//		{
//			break;
//		}
//		for (j = 0; j < en_number[i]; j++)	//반복횟수만큼 빈 배열에 데이터를 저장해야하므로 j는 en_number[i]까지 반복
//		{
//			printf("%c", en_number[i + 1]);
//			de_number[idx] = en_number[i + 1];
//			idx++;
//		}
//	}
//	printf("\n디코딩 결과 : %s\n", de_number);
//}
//
//int main() {
//	unsigned char num[N] = { '1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1','1','1','1','1','1',
//		'1','1','1','1','1','1','1','1','1' ,'1' ,'1' ,
//	   '1' ,'1' ,'1' ,'1' ,'1' ,'1', '0','0',
//	   '1','1','1','1','1','1','0','0',      0 };
//	printf("인코딩 전 : %s\n", num);
//	encoding(num);
//	printf("디코딩 과정 : ");
//	decoding(results);
//	return 0;
//}